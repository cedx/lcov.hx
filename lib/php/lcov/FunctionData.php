<?php
/**
 * Generated by Haxe 4.0.5
 */

namespace lcov;

use \php\_Boot\HxAnon;
use \php\Boot;

/**
 * Provides details for function coverage.
 */
class FunctionData implements \JsonSerializable {
	/**
	 * @var int
	 * The execution count.
	 */
	public $executionCount;
	/**
	 * @var string
	 * The function name.
	 */
	public $functionName;
	/**
	 * @var int
	 * The line number of the function start.
	 */
	public $lineNumber;

	/**
	 * Creates a new function data from the specified JSON object.
	 * @param map A JSON object representing a function data.
	 * @return The instance corresponding to the specified JSON object.
	 * 
	 * @param mixed $map
	 * 
	 * @return FunctionData
	 */
	public static function fromJson ($map) {
		#src/lcov/FunctionData.hx:37: characters 5-67
		$tmp = (Boot::is(\Reflect::field($map, "functionName"), Boot::getClass('String')) ? \Reflect::field($map, "functionName") : "");
		#src/lcov/FunctionData.hx:38: characters 5-59
		$tmp1 = (Boot::is(\Reflect::field($map, "lineNumber"), Boot::getClass('Int')) ? \Reflect::field($map, "lineNumber") : 0);
		#src/lcov/FunctionData.hx:36: lines 36-40
		return new FunctionData($tmp, $tmp1, (Boot::is(\Reflect::field($map, "executionCount"), Boot::getClass('Int')) ? \Reflect::field($map, "executionCount") : 0));
	}

	/**
	 * Creates a new function data.
	 * @param functionName The function name.
	 * @param lineNumber The line number of the function start.
	 * @param executionCount The execution count.
	 * 
	 * @param string $functionName
	 * @param int $lineNumber
	 * @param int $executionCount
	 * 
	 * @return void
	 */
	public function __construct ($functionName, $lineNumber, $executionCount = 0) {
		#src/lcov/FunctionData.hx:25: lines 25-29
		if ($executionCount === null) {
			$executionCount = 0;
		}
		#src/lcov/FunctionData.hx:26: characters 5-41
		$this->executionCount = $executionCount;
		#src/lcov/FunctionData.hx:27: characters 5-37
		$this->functionName = $functionName;
		#src/lcov/FunctionData.hx:28: characters 5-33
		$this->lineNumber = $lineNumber;
	}

	/**
	 * An alias for the `toJson()` method.
	 * 
	 * @return object
	 */
	public function jsonSerialize () {
		#src/lcov/FunctionData.hx:68: characters 34-49
		return $this->toJson();
	}

	/**
	 * Converts this object to a map in JSON format.
	 * @return The map in JSON format corresponding to this object.
	 * 
	 * @return object
	 */
	public function toJson () {
		#src/lcov/FunctionData.hx:46: lines 46-50
		return new HxAnon([
			"executionCount" => $this->executionCount,
			"functionName" => $this->functionName,
			"lineNumber" => $this->lineNumber,
		]);
	}

	/**
	 * Returns a string representation of this object.
	 * @param asDefinition Whether to return the function definition (e.g. name and line number) instead of its data (e.g. name and execution count).
	 * @return The string representation of this object.
	 * 
	 * @param bool $asDefinition
	 * 
	 * @return string
	 */
	public function toString ($asDefinition = false) {
		#src/lcov/FunctionData.hx:57: lines 57-61
		if ($asDefinition === null) {
			$asDefinition = false;
		}
		#src/lcov/FunctionData.hx:58: characters 5-74
		$token = ($asDefinition ? "FN" : "FNDA");
		#src/lcov/FunctionData.hx:59: characters 5-62
		$count = ($asDefinition ? $this->lineNumber : $this->executionCount);
		#src/lcov/FunctionData.hx:60: characters 5-41
		return "" . ($token??'null') . ":" . ($count??'null') . "," . ($this->functionName??'null');
	}

	public function __toString() {
		return $this->toString();
	}
}

Boot::registerClass(FunctionData::class, 'lcov.FunctionData');
