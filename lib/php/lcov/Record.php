<?php
/**
 * Generated by Haxe 4.0.5
 */

namespace lcov;

use \php\_Boot\HxAnon;
use \php\Boot;

/**
 * Provides the coverage data of a source file.
 */
class Record implements \JsonSerializable {
	/**
	 * @var BranchCoverage
	 * The branch coverage.
	 */
	public $branches;
	/**
	 * @var FunctionCoverage
	 * The function coverage.
	 */
	public $functions;
	/**
	 * @var LineCoverage
	 * The line coverage.
	 */
	public $lines;
	/**
	 * @var string
	 * The path to the source file.
	 */
	public $sourceFile;

	/**
	 * Creates a new record from the specified `map` in JSON format.
	 * 
	 * @param mixed $map
	 * 
	 * @return Record
	 */
	public static function fromJson ($map) {
		$tmp = (Boot::is(\Reflect::field($map, "sourceFile"), Boot::getClass('String')) ? \Reflect::field($map, "sourceFile") : "");
		$tmp1 = (\Reflect::isObject(\Reflect::field($map, "branches")) ? BranchCoverage::fromJson(\Reflect::field($map, "branches")) : null);
		$tmp2 = (\Reflect::isObject(\Reflect::field($map, "functions")) ? FunctionCoverage::fromJson(\Reflect::field($map, "functions")) : null);
		return new Record($tmp, [
			"branches" => $tmp1,
			"functions" => $tmp2,
			"lines" => (\Reflect::isObject(\Reflect::field($map, "lines")) ? LineCoverage::fromJson(\Reflect::field($map, "lines")) : null),
		]);
	}

	/**
	 * Creates a new record with the specified source file.
	 * 
	 * @param string $sourceFile
	 * @param mixed $options
	 * 
	 * @return void
	 */
	public function __construct ($sourceFile, $options = null) {
		$this->lines = null;
		$this->functions = null;
		$this->branches = null;
		$this->sourceFile = $sourceFile;
		if ($options !== null) {
			if (isset($options["branches"])) {
				$this->branches = $options["branches"];
			}
			if (isset($options["functions"])) {
				$this->functions = $options["functions"];
			}
			if (isset($options["lines"])) {
				$this->lines = $options["lines"];
			}
		}
	}

	/**
	 * An alias for the `toJson()` method.
	 * 
	 * @return object
	 */
	public function jsonSerialize () {
		return $this->toJson();
	}

	/**
	 * Converts this object to a map in JSON format.
	 * 
	 * @return object
	 */
	public function toJson () {
		$tmp = ($this->branches !== null ? $this->branches->toJson() : null);
		$tmp1 = ($this->functions !== null ? $this->functions->toJson() : null);
		$tmp2 = ($this->lines !== null ? $this->lines->toJson() : null);
		return new HxAnon([
			"branches" => $tmp,
			"functions" => $tmp1,
			"lines" => $tmp2,
			"sourceFile" => $this->sourceFile,
		]);
	}

	/**
	 * Returns a string representation of this object.
	 * 
	 * @return string
	 */
	public function toString () {
		$output = \Array_hx::wrap(["" . ("SF"??'null') . ":" . ($this->sourceFile??'null')]);
		if ($this->functions !== null) {
			$x = $this->functions->toString();
			$output->arr[$output->length] = $x;
			++$output->length;
		}
		if ($this->branches !== null) {
			$x1 = $this->branches->toString();
			$output->arr[$output->length] = $x1;
			++$output->length;
		}
		if ($this->lines !== null) {
			$x2 = $this->lines->toString();
			$output->arr[$output->length] = $x2;
			++$output->length;
		}
		$output->arr[$output->length] = "end_of_record";
		++$output->length;

		return $output->join("\x0A");
	}

	public function __toString() {
		return $this->toString();
	}
}

Boot::registerClass(Record::class, 'lcov.Record');
